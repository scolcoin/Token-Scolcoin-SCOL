# Whitepaper Token Scol (Scolcoin) 2.0 Our Smart Contracts

## Binance Smart Chain (BSC)

Our smart Contracts are BEP-20. For Techincal Details on BEP-20 Standard: https://academy.binance.com/en/glossary/bep-20

Scolcoin (SCOL) tokens were written in Solidity. Be sure to check out their tutorial before jumping into code: https://solidity.readthedocs.io/en/v0.6.9/introduction-to-smart-contracts.html

Implementations of standards ERC20

Source code: https://github.com/scolcoin/Token-Scolcoin-SCOL/blob/main/scolcoin.sol

## OpenZeppelin - The secure implementation

Our Smart Contracts are based on secure and trusted [OpenZeppelin ERC-20 Smart Contract](https://docs.openzeppelin.com/contracts/4.x/erc20)

OpenZeppelin code is at the heart of our tokens and we follow their security practices and implementation very carefully.

# Scolcoin (SCOL) Token

This token is a standard ERC-20 implementation and was deployed on Binance Smart Chain mainnet with fixed Max Supply of 80,000,000 SCOL. 1 SCOL tokens were ultimately. To bootstrap the Scolcoin Native Blockchain ecosystem.

Mainnet Deployed Scolcoin (SCOL) Token can be found here: https://bscscan.com/token/0x703477125bbee6430b2c4968c1ef66701a01359f

Compilation Parameters: Solidity 0.8.10+commit.fc410830. Optimization 200

## Scolcoin project
Our project was born on January 3, 2018 with the genesis block of the native Scolcoin blockchain (SCOL) that currently works parallel to our token. It evolved with the 2.0.0.2 whitepaper where the mining and investment funds bet was born, which is reflected in Token Scolcoin

* Link Whitepaper 2.0.0.2 native Scolcoin blockchain
https://github.com/scolcoin/Whitepaper/blob/main/White%20Paper%20Scolcoin%20ver%202.0.0.2.pdf

## Cryptocurrency SCOLCOIN (SCOL) Blockchain Native 2018 - 2021
The Scolcoin Social Project in its creation stage was presented to the community as the ecological Colombian digital asset for reaching the Proof of Stake phase, achieving positioning and recognition in LatAm. Its genesis block was made on January 3, 2018, the committees and presence in communities were formed

* Link Code native Scolcoin blockchain
https://github.com/scolcoin/scolcoin
* Scolcoin Blockchain Explorer
https://chainz.cryptoid.info/scol/

# Specifications SCOL
* Coin name  SColcoin
* Coin abbreviation SCOL
* algoritmo: Scrypt
* Tipo: PoW/PoS
* Letra Direccion: S
* RPC port  31498
* P2P port   31497
* Total coin supply: 80.000.000 coins
* PoS percentage : 10% per year
* Last PoW block:  block 10000
* Coinbase maturity : 100 blocks
* Target spacing: 64 seconds
* Target timespan: 1 block
* Transaction confirmations: 6 blocks

## Scol 2.0 Create Token.
Scolcoin launches a mining Pool for its community at the following address: 
* Wallet: SZoZvuRvD7aoPPVBZr89vAVb9wnCL8aGEW
* Explorer: https://chainz.cryptoid.info/scol/address.dws?SZoZvuRvD7aoPPVBZr89vAVb9wnCL8aGEW.htm
Establish itself in the international market with an investment strategy and a liquidity fund thanks to the Scolcoin Token
Pool Miner + Investment (Liquidity Fund) = Token Scol

## Token Scolcoin (2021 -2022)
Developed as a backup token for the community Scolcoin is born on the day.

based on the wallet SZoZvuRvD7aoPPVBZr89vAVb9wnCL8aGEW link explorador: https://chainz.cryptoid.info/scol/address.dws?SZoZvuRvD7aoPPVBZr89vAVb9wnCL8aGEW.htm

// contracts/BEP20.sol
Source Code: https://github.com/scolcoin/Token-Scolcoin-SCOL
Link Contract: https://bscscan.com/address/0x703477125bbee6430b2c4968c1ef66701a01359f#code

/// @custom:security-contact info@scolcoin.com
/***********************************************************
Scolcoin (SCOL) cryptocurrency backup and investment toke
************************************************************/  
// Copyright (c) 2018-2021 Scolcoin (SCOL) Native Blockchain
// Copyright (c) 2021-2022 Scolcoin (SCOL) token BEP20

/*--------------------------------------------------------------- @dev
 * Exclusive premier investment pool for the community SCOLCOIN 2.0 Token
 * maximum profitability and liquidity. converts SCOL native <> SCOL Token.
*/

/* < Block Genesis Token >
 - Total Supply: 80.000.000 SCOL token
 - Initial Supply: 1 SCOL Token
 + Coin support:   1 SCOL (native blockchain)
 Details Pool Bep20
 Wallet: SZoZvuRvD7aoPPVBZr89vAVb9wnCL8aGEW
 Explorer: https://chainz.cryptoid.info/scol/address.dws?SZoZvuRvD7aoPPVBZr89vAVb9wnCL8aGEW.htm
 Hash Genesis Scol Native 93516d2b91f309ec151a26eab14a3662f408a58786f12a61fdb67fad305c275e
*/

## Pool Miner
Staking SCOL 2.0 by sending the funds to the Pool's wallet and entering its hash with minimum requirements and the maximum profitability of 10% per year. You cannot redeem your stake during the first phase, 2 years. pool.scolcoin.com converts native SCOLs into tokens as the only proof of your stake SCOLs with a 1: 1 ratio. with the requirement of entering an investment to the liquidity fund of the token.

* Reward distribution (Staking)
Every 30 days we distribute the rewards generated on the native Scolcoin blockchain among all participants based on their Scolcoin token position. These rewards are distributed in Scol Nativo to the wallets registered in pool.scolcoin.com of the users.

* Withdrawal of funds
You will be able to exchange your Scolcoin token for Scolcoin Nativo when the first phase 2 years ends

## Investment (Liquidity Fund)
A collective investment fund Scolcoin also called liquidity in the de-centralized exchanges, this block consists of gathering funds from different investors, natural or legal, to leverage the Token Scolcoin asset in the current DELFIs with different pairs, managing to capitalize the project through the holding of 2 years receiving direct rewards to their wallets with Scolcoin Nativo, by mining in proof of stake 10% per year. the resources will be applied directly in the form of liquidity in different pairs.
Liquidity Providers earn trading and Staking commissions

# Trading Liquidity:
Providing liquidity gives you a reward in the form of trading fees when people use your liquidity pool (your added currency pair)

# Staking reward
Thanks to the Scolcoin Nativo Mining Pool, compensation will be given according to the hold that each person has in the token (10% per year), the profits are distributed monthly.

# Referral by Investment
The liquidity fund commissioners when registering their guests who carry out the process will have a direct commission to their wallets in native scolcoin of 3% to 15% of the investment made to the fund.

# Table:
* Commission 15% for amounts less than $ 1,000 USDT
* 10% commission for amounts between $ 1,000 and $ 3,000 USDT
* Commission 5% for amounts between $ 3,001 and $ 10,000 USDT
* Commission 3% for amounts over $ 10,001 USDT
* Note: all commissions are paid in Scolcoin (SCOL) Nativo

# 1 Phase
Implementation of the Oracle Scolcoin system.

# 2 Phase
Implementation of the conversion system (Swap) this will be done by an API designed for the Scolcoin community designed to exchange all currencies for token by performing a multiblockchain.

# 3 Phase 
PAD project integration with the Scolcoin API multiblockchain system.

# Oracle Definition:
Statistical portal of the blockchain chains currently owned by the SCOL project.

## Roadmap

# Q1 2021
*- November 2021 - Create Token Scolcoin (whitepaper, ANN, Exchange)

# Q2 2021
* December 2021 - Launch of the Mining Pool and Liquidity Fund.
* Start pool mining. 
* start liquidity pool.
* (1 phase: duration 2 year)

# Q1 2022
* January to December - Sale of assets through stock brokers and / or brokers
* Payment of mining pool rewards (period monthly)

# Q1 2023
* January - Oracle Platform Development (2 phase).

# Q2 2023
* June - PAD project Platform Development (3 phase).

# Q1 2024
* January - Withdrawal time mining pool (1 phase).

# Q1 2025
* January - PAD Project launch (3 phase).

## Libraries & Interfaces

```Solidity
pragma solidity ^0.8.2;
```
We've deployed Scolcoin token to mainnet with solidity ^0.8.2.

```Solidity
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
```
Right away we get into the heavy usage of OpenZeppelin secure libraries. This is the base ERC-20 implementation that SCOL is based on.

```Solidity
import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol";
```
We've already included scolcoin.sol, why include the interface? SCOL smart contract accepts a _token as one of the constructore parameters. We'll discuss this in the **constructor** section below.

## ERC20Burnable
Our Token can perform the function of Burning Token, make Repurchases to be able to Burn Tokens

** _burn(account, amount); **

Code:

```Solidity
/**
 * @dev Extension of {ERC20} that allows token holders to destroy both their own
 * tokens and those that they have an allowance for, in a way that can be
 * recognized off-chain (via event analysis).
 */
abstract contract ERC20Burnable is Context, ERC20 {
    /**
     * @dev Destroys `amount` tokens from the caller.
     *
     * See {ERC20-_burn}.
     */
    function burn(uint256 amount) public virtual {
        _burn(_msgSender(), amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`, deducting from the caller's
     * allowance.
     *
     * See {ERC20-_burn} and {ERC20-allowance}.
     *
     * Requirements:
     *
     * - the caller must have allowance for ``accounts``'s tokens of at least
     * `amount`.
     */
    function burnFrom(address account, uint256 amount) public virtual {
        uint256 currentAllowance = allowance(account, _msgSender());
        require(currentAllowance >= amount, "ERC20: burn amount exceeds allowance");
        unchecked {
            _approve(account, _msgSender(), currentAllowance - amount);
        }
        _burn(account, amount);
    }
}

// File: contracts/scolcoin.sol
```

## ERC20Snapshot
With the Snapshop function it allows us to get support from the token at any time to have it for consultations for defined seasons for a consecutive one, or to take balances from all the holders

** _snapshot(); **

Code:

```Solidity
abstract contract ERC20Snapshot is ERC20 {
    // Inspired by Jordi Baylina's MiniMeToken to record historical balances:
    // https://github.com/Giveth/minimd/blob/ea04d950eea153a04c51fa510b068b9dded390cb/contracts/MiniMeToken.sol

    using Arrays for uint256[];
    using Counters for Counters.Counter;

    // Snapshotted values have arrays of ids and the value corresponding to that id. These could be an array of a
    // Snapshot struct, but that would impede usage of functions that work on an array.
    struct Snapshots {
        uint256[] ids;
        uint256[] values;
    }

    mapping(address => Snapshots) private _accountBalanceSnapshots;
    Snapshots private _totalSupplySnapshots;

    // Snapshot ids increase monotonically, with the first value being 1. An id of 0 is invalid.
    Counters.Counter private _currentSnapshotId;

    /**
     * @dev Emitted by {_snapshot} when a snapshot identified by `id` is created.
     */
    event Snapshot(uint256 id);

    /**
     * @dev Creates a new snapshot and returns its snapshot id.
     *
     * Emits a {Snapshot} event that contains the same id.
     *
     * {_snapshot} is `internal` and you have to decide how to expose it externally. Its usage may be restricted to a
     * set of accounts, for example using {AccessControl}, or it may be open to the public.
     *
     * [WARNING]
     * ====
     * While an open way of calling {_snapshot} is required for certain trust minimization mechanisms such as forking,
     * you must consider that it can potentially be used by attackers in two ways.
     *
     * First, it can be used to increase the cost of retrieval of values from snapshots, although it will grow
     * logarithmically thus rendering this attack ineffective in the long term. Second, it can be used to target
     * specific accounts and increase the cost of ERC20 transfers for them, in the ways specified in the Gas Costs
     * section above.
     *
     * We haven't measured the actual numbers; if this is something you're interested in please reach out to us.
     * ====
     */
    function _snapshot() internal virtual returns (uint256) {
        _currentSnapshotId.increment();

        uint256 currentId = _getCurrentSnapshotId();
        emit Snapshot(currentId);
        return currentId;
    }

    /**
     * @dev Get the current snapshotId
     */
    function _getCurrentSnapshotId() internal view virtual returns (uint256) {
        return _currentSnapshotId.current();
    }

    /**
     * @dev Retrieves the balance of `account` at the time `snapshotId` was created.
     */
    function balanceOfAt(address account, uint256 snapshotId) public view virtual returns (uint256) {
        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _accountBalanceSnapshots[account]);

        return snapshotted ? value : balanceOf(account);
    }

    /**
     * @dev Retrieves the total supply at the time `snapshotId` was created.
     */
    function totalSupplyAt(uint256 snapshotId) public view virtual returns (uint256) {
        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _totalSupplySnapshots);

        return snapshotted ? value : totalSupply();
    }

    // Update balance and/or total supply snapshots before the values are modified. This is implemented
    // in the _beforeTokenTransfer hook, which is executed for _mint, _burn, and _transfer operations.
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        super._beforeTokenTransfer(from, to, amount);

        if (from == address(0)) {
            // mint
            _updateAccountSnapshot(to);
            _updateTotalSupplySnapshot();
        } else if (to == address(0)) {
            // burn
            _updateAccountSnapshot(from);
            _updateTotalSupplySnapshot();
        } else {
            // transfer
            _updateAccountSnapshot(from);
            _updateAccountSnapshot(to);
        }
    }

    function _valueAt(uint256 snapshotId, Snapshots storage snapshots) private view returns (bool, uint256) {
        require(snapshotId > 0, "ERC20Snapshot: id is 0");
        require(snapshotId <= _getCurrentSnapshotId(), "ERC20Snapshot: nonexistent id");

        // When a valid snapshot is queried, there are three possibilities:
        //  a) The queried value was not modified after the snapshot was taken. Therefore, a snapshot entry was never
        //  created for this id, and all stored snapshot ids are smaller than the requested one. The value that corresponds
        //  to this id is the current one.
        //  b) The queried value was modified after the snapshot was taken. Therefore, there will be an entry with the
        //  requested id, and its value is the one to return.
        //  c) More snapshots were created after the requested one, and the queried value was later modified. There will be
        //  no entry for the requested id: the value that corresponds to it is that of the smallest snapshot id that is
        //  larger than the requested one.
        //
        // In summary, we need to find an element in an array, returning the index of the smallest value that is larger if
        // it is not found, unless said value doesn't exist (e.g. when all values are smaller). Arrays.findUpperBound does
        // exactly this.

        uint256 index = snapshots.ids.findUpperBound(snapshotId);

        if (index == snapshots.ids.length) {
            return (false, 0);
        } else {
            return (true, snapshots.values[index]);
        }
    }

    function _updateAccountSnapshot(address account) private {
        _updateSnapshot(_accountBalanceSnapshots[account], balanceOf(account));
    }

    function _updateTotalSupplySnapshot() private {
        _updateSnapshot(_totalSupplySnapshots, totalSupply());
    }

    function _updateSnapshot(Snapshots storage snapshots, uint256 currentValue) private {
        uint256 currentId = _getCurrentSnapshotId();
        if (_lastSnapshotId(snapshots.ids) < currentId) {
            snapshots.ids.push(currentId);
            snapshots.values.push(currentValue);
        }
    }

    function _lastSnapshotId(uint256[] storage ids) private view returns (uint256) {
        if (ids.length == 0) {
            return 0;
        } else {
            return ids[ids.length - 1];
        }
    }
}
// File: contracts/scolcoin.sol
```

## AccessControl
Access control—that is, "who is allowed to do this thing"—is incredibly important in the world of smart contracts. The access control of your contract may govern who can mint tokens, freeze transfers, and many other things. It is therefore critical to understand how you implement it, lest someone else steals your whole system.

Code:

```Solidity
pragma solidity ^0.8.0;

/**
 * @dev String operations.
 */
library Strings {
    bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";

    /**
     * @dev Converts a `uint256` to its ASCII `string` decimal representation.
     */
    function toString(uint256 value) internal pure returns (string memory) {
        // Inspired by OraclizeAPI's implementation - MIT licence
        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol

        if (value == 0) {
            return "0";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
     */
    function toHexString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return "0x00";
        }
        uint256 temp = value;
        uint256 length = 0;
        while (temp != 0) {
            length++;
            temp >>= 8;
        }
        return toHexString(value, length);
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
     */
    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
        bytes memory buffer = new bytes(2 * length + 2);
        buffer[0] = "0";
        buffer[1] = "x";
        for (uint256 i = 2 * length + 1; i > 1; --i) {
            buffer[i] = _HEX_SYMBOLS[value & 0xf];
            value >>= 4;
        }
        require(value == 0, "Strings: hex length insufficient");
        return string(buffer);
    }
}

// File: @openzeppelin/contracts/access/IAccessControl.sol

```

## Pausable
the ability to for all system operations with the system administrator, this allows to prevent losses.

Code:

```Solidity
pragma solidity ^0.8.0;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

// File: @openzeppelin/contracts/security/Pausable.sol
```
