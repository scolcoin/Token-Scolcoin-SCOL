# Whitepaper Español Token Scol (Scolcoin) Smart Contracts

## Binance Smart Chain (BSC)

Nuestro contrato inteligente es BEP-20. Para obtener detalles técnicos sobre el estándar BEP-20: https://academy.binance.com/en/glossary/bep-20

Scolcoin (SCOL) token desarrollado en Solidity. Asegúrese de consultar su tutorial: https://solidity.readthedocs.io/en/v0.6.9/introduction-to-smart-contracts.html

Implementaciones de estándares ERC20

Source code: https://github.com/scolcoin/Token-Scolcoin-SCOL/blob/main/scolcoin.sol

## OpenZeppelin - Implementación segura

Nuestros Smart Contracts se basan en seguros y confiables [OpenZeppelin ERC-20 Smart Contract](https://docs.openzeppelin.com/contracts/4.x/erc20)

OpenZeppelin el código está en el corazón de nuestros tokens y seguimos sus prácticas de seguridad e implementación con mucho cuidado.

# Token Scolcoin (SCOL) 

Este token es una implementación estándar de ERC-20 y se implementó en la red principal de Binance Smart Chain con un suministro máximo fijo de 80,000,000 SCOL. Creacion de 1 SCOL tokens. Para arrancar el ecosistema Scolcoin Native Blockchain.

Mainnet Deployed Scolcoin (SCOL) Token can be found here: https://bscscan.com/token/0x703477125bbee6430b2c4968c1ef66701a01359f

Parámetros de compilación: Solidity 0.8.10+commit.fc410830. Optimización 200

## Proyecto Scolcoin
Nuestro proyecto nació el 3 de enero de 2018 con el bloque génesis de la cadena de bloques nativa Scolcoin (SCOL) que actualmente funciona en paralelo a nuestro token. Evolucionó con el whitepaper 2.0.0.2 donde nació la apuesta de los fondos de inversión y minería, que se refleja en Token Scolcoin.

* Link Whitepaper 2.0.0.2 Scolcoin Nativo Blockchain
https://github.com/scolcoin/Whitepaper/blob/main/White%20Paper%20Scolcoin%20ver%202.0.0.2.pdf

## Criptomoneda SCOLCOIN (SCOL) Blockchain Nativa 2018 - 2021
El Proyecto Social Scolcoin en su etapa de creación fue presentado a la comunidad como el activo digital ecológico colombiano para alcanzar la fase Proof of Stake, logrando posicionamiento y reconocimiento en LatAm. Su bloque de génesis se realizó el 3 de enero de 2018, se conformaron los comités y presencia en comunidades.

* Link Código Scolcoin blockchain
https://github.com/scolcoin/scolcoin

* Scolcoin Blockchain Explorer
https://chainz.cryptoid.info/scol/

## Característica Scolcoin
* Nombre  SColcoin
* Abreviatura SCOL
* algoritmo: Scrypt
* Tipo: PoW/PoS
* Letra Direccion: S
* RPC port  31498
* P2P port   31497
* Total coin supply: 80.000.000 coins
* PoS percentage : 10% per year
* Last PoW block:  block 10000
* Coinbase maturity : 100 blocks
* Target spacing: 64 seconds
* Target timespan: 1 block
* Transaction confirmations: 6 blocks

# Creación Scol 2.0 Token.
Scolcoin lanza un grupo de minería para su comunidad en la siguiente dirección: 
* Wallet: SraiZ7pa5Py9Y4LYdY4W3CN2JoDmyQEcEd
* Explorer: https://chainz.cryptoid.info/scol/address.dws?SraiZ7pa5Py9Y4LYdY4W3CN2JoDmyQEcEd.htm
Establecerse en el mercado internacional con una estrategia de inversión y un fondo de liquidez gracias al Token Scolcoin
* Pool Miner + Investment (Liquidity Fund) = Token Scol

## Token Scolcoin (2021 -2022)
Desarrollado como un token de respaldo para la comunidad, Scolcoin nace el día.

Basado en la wallet SraiZ7pa5Py9Y4LYdY4W3CN2JoDmyQEcEd link explorador: https://chainz.cryptoid.info/scol/address.dws?SraiZ7pa5Py9Y4LYdY4W3CN2JoDmyQEcEd.htm

// contracts/BEP20.sol
Source Code: https://github.com/scolcoin/Token-Scolcoin-SCOL
Link Contract: https://bscscan.com/address/0x703477125bbee6430b2c4968c1ef66701a01359f#code

* /// @custom:security-contact info@scolcoin.com
* /***********************************************************
* Scolcoin (SCOL) cryptocurrency backup and investment toke
* ************************************************************/  
* // Copyright (c) 2018-2021 Scolcoin (SCOL) Native Blockchain
* // Copyright (c) 2021-2022 Scolcoin (SCOL) token BEP20

/*--------------------------------------------------------------- @dev
 * Exclusive premier investment pool for the community SCOLCOIN 2.0 Token
 * maximum profitability and liquidity. converts SCOL native <> SCOL Token.
*/

/* < Block Genesis Token >
 - Total Supply: 80.000.000 SCOL token
 - Initial Supply: 1 SCOL Token
 + Coin support:   1 SCOL (native blockchain)
 Details Pool Bep20
 Wallet: SraiZ7pa5Py9Y4LYdY4W3CN2JoDmyQEcEd
 Explorer: https://chainz.cryptoid.info/scol/address.dws?SraiZ7pa5Py9Y4LYdY4W3CN2JoDmyQEcEd.htm
 Hash Genesis Scol Native 93516d2b91f309ec151a26eab14a3662f408a58786f12a61fdb67fad305c275e
*/

## Pool Miner
Staking SCOL 2.0 enviando los fondos a la billetera del Pool e ingresando su hash con requisitos mínimos y la rentabilidad máxima del 10% anual. No puede canjear su apuesta durante la primera fase, 2 años. pool.scolcoin.com convierte los SCOL nativos en tokens como la única prueba de sus SCOL de participación con una proporción de 1:1. con el requisito de ingresar una inversión al fondo de liquidez del token.

# Distribución de recompensas (Staking)

Cada 30 días distribuimos las recompensas generadas en la cadena de bloques nativa de Scolcoin entre todos los participantes en función de su posición de token de Scolcoin. Estas recompensas se distribuyen en Scol Nativo a las billeteras registradas en pool.scolcoin.com de los usuarios.

# Retiro de fondos

Podrás canjear tu token Scolcoin por Scolcoin Nativo cuando finalice la primera fase 2 años.

## Investment (Fondo Liquidez)
Un fondo de inversión colectiva Scolcoin también llamado liquidez en los intercambios descentralizados, este bloque consiste en recolectar fondos de diferentes inversionistas, naturales o legales, para apalancar el activo Token Scolcoin en los DELFIs actuales con diferentes pares, logrando capitalizar el proyecto a través de la tenencia de 2 años recibiendo recompensas directas a sus billeteras con Scolcoin Nativo, mediante minería en prueba de participación 10% anual. los recursos se aplicarán directamente en forma de liquidez en diferentes pares.
Los proveedores de liquidez ganan comisiones de negociación y participación.

## Los Proveedores de Liquidez ganan comisiones de trading
Proporcionar liquidez le da una recompensa en forma de tarifas de trading cuando las personas utilizan su fondo de liquidez (su par de monedas agregado). Cada vez que alguien opera en PancakeSwap, el operador paga una tarifa del 0.25%, de la cual el 0.17% se agrega al Fondo de Liquidez del par de swaps en el que operaron.

# Trading Liquidez:
Brindar liquidez le brinda una recompensa en forma de tarifas comerciales cuando las personas usan su fondo de liquidez (su par de divisas agregado).

# Recompensa por Staking
Gracias al Pool Minero Scolcoin Nativo, se dará una compensación de acuerdo a la tenencia que cada persona tenga en el token (10% anual), las ganancias se distribuyen mensualmente.

# Referido por Inversion
Los comisionados del fondo de liquidez al registrar a sus invitados que realicen el proceso tendrán una comisión directa a sus billeteras en scolcoin nativo del 3% al 15% de la inversión realizada al fondo.

# Table:
* Comisión 15% por montos menores a $ 1,000 USDT
* 10% de comisión por montos entre $ 1,000 y $ 3,000 USDT
* Comisión 5% para montos entre $ 3,001 y $ 10,000 USDT
* Comisión 3% por montos superiores a $ 10,001 USDT
**** Nota: todas las comisiones se pagan en Scolcoin (SCOL) Nativo

## Desarrollo:

# 1 Fase:
Implementación del sistema Oraculo Scolcoin (blockchain).

# 2 Fase:
La implementación del sistema de conversión (Swap) se realizará mediante una API diseñada para la comunidad Scolcoin diseñada para intercambiar todas las monedas por token mediante la realización de una multiblockchain.

# 3 Fase:
Integración del proyecto PAD con el sistema multiblockchain API de Scolcoin. El proyecto PAD contiene un motor basado en inteligencia artificial para generar contratos inteligentes sobre una maquina virtual Scolcoin, con backup en redes publicas como soporte.

# Definición Oraculo Blockchain:
Portal estadístico de las cadenas blockchain actualmente propiedad del proyecto SCOL.

## Conversión:
la distribucion se realiza con la siguiente formula:
* Scolcoin Nativos (pool staking) + $liquidez = Scolcoin Token  <2 años en staking>

Nota: si tienen Criptomonedas nativas Scol podran minar en el pool de mineria y recibiras el token Scolcoin como respaldo del pool y adicional debes invertir en el fondo de liquidez para apalancar el token, esto te dara como resultado el Token Scolcoin.

o si tienes Token Scolcoin:
* podras cambiar al valor real por la criptomoneda scolcoin nativa para realizar intercambios. los token obtenidos se almacenaran en la wallet desarrollo 0xfDa31C592cdA440C88097A2C9ea0C4F8D69931aD.

## Roadmap

# Q1 2021
* Noviembre de 2021: creación de Token Scolcoin (documento técnico, ANN, Exchange)

# Q2 2021
* Diciembre de 2021 - Lanzamiento del Fondo Pool Minero y Fondo de Liquidez.
* Inicio pool Minado. 
* Inicio pool Loquidez.
* (1 phase: Duración 2 Años)

# Q1 2022
* Enero a diciembre - Venta de activos a través de corredores de bolsa y / o corredores.
* Pago de recompensas del pool de minería (período mensual)

# Q1 2023
* Enero - Desarrollo de la plataforma Oracle (2 fases).

# Q2 2023
* Junio - Desarrollo de la plataforma del proyecto PAD (3 fases).

# Q1 2024
* Enero - Pool de minería de tiempo de retirada (1 fase).

# Q1 2025
* Enero - Lanzamiento del proyecto PAD (3 fases).

## Bibliotecas e interfaces

```Solidity
pragma solidity ^0.8.2;
```
Nosotros hemos desplegado Scolcoin token to mainnet with solidity ^0.8.2.

```Solidity
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
```
De inmediato nos adentramos en el uso intensivo de las bibliotecas seguras de OpenZeppelin. Esta es la implementación básica de ERC-20 en la que se basa SCOL.

```Solidity
import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol";
```
Ya hemos incluido scolcoin.sol, ¿por qué incluir la interfaz? El contrato inteligente de SCOL acepta un _token como uno de los parámetros de construcción. Discutiremos esto en la sección ** constructor ** a continuación.

## ERC20Burnable
Nuestro Token puede realizar la función de Burning Token, realizar Recompras para poder Quemar Tokens.

** _burn(account, amount); **

Code:

```Solidity
/**
 * @dev Extension of {ERC20} that allows token holders to destroy both their own
 * tokens and those that they have an allowance for, in a way that can be
 * recognized off-chain (via event analysis).
 */
abstract contract ERC20Burnable is Context, ERC20 {
    /**
     * @dev Destroys `amount` tokens from the caller.
     *
     * See {ERC20-_burn}.
     */
    function burn(uint256 amount) public virtual {
        _burn(_msgSender(), amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`, deducting from the caller's
     * allowance.
     *
     * See {ERC20-_burn} and {ERC20-allowance}.
     *
     * Requirements:
     *
     * - the caller must have allowance for ``accounts``'s tokens of at least
     * `amount`.
     */
    function burnFrom(address account, uint256 amount) public virtual {
        uint256 currentAllowance = allowance(account, _msgSender());
        require(currentAllowance >= amount, "ERC20: burn amount exceeds allowance");
        unchecked {
            _approve(account, _msgSender(), currentAllowance - amount);
        }
        _burn(account, amount);
    }
}

// File: contracts/scolcoin.sol
```

## ERC20Snapshot
Con la función Snapshop nos permite obtener soporte del token en cualquier momento para tenerlo para consultas por temporadas definidas por una consecutiva, o tomar saldos de todos los titulares.

** _snapshot(); **

Code:

```Solidity
abstract contract ERC20Snapshot is ERC20 {
    // Inspired by Jordi Baylina's MiniMeToken to record historical balances:
    // https://github.com/Giveth/minimd/blob/ea04d950eea153a04c51fa510b068b9dded390cb/contracts/MiniMeToken.sol

    using Arrays for uint256[];
    using Counters for Counters.Counter;

    // Snapshotted values have arrays of ids and the value corresponding to that id. These could be an array of a
    // Snapshot struct, but that would impede usage of functions that work on an array.
    struct Snapshots {
        uint256[] ids;
        uint256[] values;
    }

    mapping(address => Snapshots) private _accountBalanceSnapshots;
    Snapshots private _totalSupplySnapshots;

    // Snapshot ids increase monotonically, with the first value being 1. An id of 0 is invalid.
    Counters.Counter private _currentSnapshotId;

    /**
     * @dev Emitted by {_snapshot} when a snapshot identified by `id` is created.
     */
    event Snapshot(uint256 id);

    /**
     * @dev Creates a new snapshot and returns its snapshot id.
     *
     * Emits a {Snapshot} event that contains the same id.
     *
     * {_snapshot} is `internal` and you have to decide how to expose it externally. Its usage may be restricted to a
     * set of accounts, for example using {AccessControl}, or it may be open to the public.
     *
     * [WARNING]
     * ====
     * While an open way of calling {_snapshot} is required for certain trust minimization mechanisms such as forking,
     * you must consider that it can potentially be used by attackers in two ways.
     *
     * First, it can be used to increase the cost of retrieval of values from snapshots, although it will grow
     * logarithmically thus rendering this attack ineffective in the long term. Second, it can be used to target
     * specific accounts and increase the cost of ERC20 transfers for them, in the ways specified in the Gas Costs
     * section above.
     *
     * We haven't measured the actual numbers; if this is something you're interested in please reach out to us.
     * ====
     */
    function _snapshot() internal virtual returns (uint256) {
        _currentSnapshotId.increment();

        uint256 currentId = _getCurrentSnapshotId();
        emit Snapshot(currentId);
        return currentId;
    }

    /**
     * @dev Get the current snapshotId
     */
    function _getCurrentSnapshotId() internal view virtual returns (uint256) {
        return _currentSnapshotId.current();
    }

    /**
     * @dev Retrieves the balance of `account` at the time `snapshotId` was created.
     */
    function balanceOfAt(address account, uint256 snapshotId) public view virtual returns (uint256) {
        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _accountBalanceSnapshots[account]);

        return snapshotted ? value : balanceOf(account);
    }

    /**
     * @dev Retrieves the total supply at the time `snapshotId` was created.
     */
    function totalSupplyAt(uint256 snapshotId) public view virtual returns (uint256) {
        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _totalSupplySnapshots);

        return snapshotted ? value : totalSupply();
    }

    // Update balance and/or total supply snapshots before the values are modified. This is implemented
    // in the _beforeTokenTransfer hook, which is executed for _mint, _burn, and _transfer operations.
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        super._beforeTokenTransfer(from, to, amount);

        if (from == address(0)) {
            // mint
            _updateAccountSnapshot(to);
            _updateTotalSupplySnapshot();
        } else if (to == address(0)) {
            // burn
            _updateAccountSnapshot(from);
            _updateTotalSupplySnapshot();
        } else {
            // transfer
            _updateAccountSnapshot(from);
            _updateAccountSnapshot(to);
        }
    }

    function _valueAt(uint256 snapshotId, Snapshots storage snapshots) private view returns (bool, uint256) {
        require(snapshotId > 0, "ERC20Snapshot: id is 0");
        require(snapshotId <= _getCurrentSnapshotId(), "ERC20Snapshot: nonexistent id");

        // When a valid snapshot is queried, there are three possibilities:
        //  a) The queried value was not modified after the snapshot was taken. Therefore, a snapshot entry was never
        //  created for this id, and all stored snapshot ids are smaller than the requested one. The value that corresponds
        //  to this id is the current one.
        //  b) The queried value was modified after the snapshot was taken. Therefore, there will be an entry with the
        //  requested id, and its value is the one to return.
        //  c) More snapshots were created after the requested one, and the queried value was later modified. There will be
        //  no entry for the requested id: the value that corresponds to it is that of the smallest snapshot id that is
        //  larger than the requested one.
        //
        // In summary, we need to find an element in an array, returning the index of the smallest value that is larger if
        // it is not found, unless said value doesn't exist (e.g. when all values are smaller). Arrays.findUpperBound does
        // exactly this.

        uint256 index = snapshots.ids.findUpperBound(snapshotId);

        if (index == snapshots.ids.length) {
            return (false, 0);
        } else {
            return (true, snapshots.values[index]);
        }
    }

    function _updateAccountSnapshot(address account) private {
        _updateSnapshot(_accountBalanceSnapshots[account], balanceOf(account));
    }

    function _updateTotalSupplySnapshot() private {
        _updateSnapshot(_totalSupplySnapshots, totalSupply());
    }

    function _updateSnapshot(Snapshots storage snapshots, uint256 currentValue) private {
        uint256 currentId = _getCurrentSnapshotId();
        if (_lastSnapshotId(snapshots.ids) < currentId) {
            snapshots.ids.push(currentId);
            snapshots.values.push(currentValue);
        }
    }

    function _lastSnapshotId(uint256[] storage ids) private view returns (uint256) {
        if (ids.length == 0) {
            return 0;
        } else {
            return ids[ids.length - 1];
        }
    }
}
// File: contracts/scolcoin.sol
```

## AccessControl
El control de acceso, es decir, "a quién se le permite hacer esto", es increíblemente importante en el mundo de los contratos inteligentes. El control de acceso de su contrato puede regir quién puede acuñar tokens, congelar transferencias y muchas otras cosas. Por lo tanto, es fundamental comprender cómo lo implementa, no sea que alguien más robe todo su sistema.

Code:

```Solidity
pragma solidity ^0.8.0;

/**
 * @dev String operations.
 */
library Strings {
    bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";

    /**
     * @dev Converts a `uint256` to its ASCII `string` decimal representation.
     */
    function toString(uint256 value) internal pure returns (string memory) {
        // Inspired by OraclizeAPI's implementation - MIT licence
        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol

        if (value == 0) {
            return "0";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
     */
    function toHexString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return "0x00";
        }
        uint256 temp = value;
        uint256 length = 0;
        while (temp != 0) {
            length++;
            temp >>= 8;
        }
        return toHexString(value, length);
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
     */
    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
        bytes memory buffer = new bytes(2 * length + 2);
        buffer[0] = "0";
        buffer[1] = "x";
        for (uint256 i = 2 * length + 1; i > 1; --i) {
            buffer[i] = _HEX_SYMBOLS[value & 0xf];
            value >>= 4;
        }
        require(value == 0, "Strings: hex length insufficient");
        return string(buffer);
    }
}

// File: @openzeppelin/contracts/access/IAccessControl.sol

```

## Pausable
la capacidad de realizar todas las operaciones del sistema con el administrador del sistema, esto permite evitar pérdidas.

Code:

```Solidity
pragma solidity ^0.8.0;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

// File: @openzeppelin/contracts/security/Pausable.sol
```
## Exchange
* SCOL / WBNB https://pancakeswap.finance/info/pool/0x0af9a331cdd540ead58f03d5d7597ffb174bfa60

* USDT / SCOL https://pancakeswap.finance/info/pool/0xa12e7b2b2c1c5e8826ce00a59ad5aa4b1274b3b8

* SCOL / BUSD https://pancakeswap.finance/info/pool/0x283879f1940730862e8b010fab0f49ed1ad8db43

* Cake / SCOL https://pancakeswap.finance/info/pool/0xe1d4efb7f6ee956ef4298149122eddaa91f13e29

### ANN
https://bitcointalk.org/index.php?topic=5373860.msg58569225
